import deepmerge from 'deepmerge';
// Cannot import from the @ngrx/store package due to a module resolution issue.
// See Issue #206.
const INIT_ACTION = '@ngrx/store/init';
const UPDATE_ACTION = '@ngrx/store/update-reducers';
const detectDate = /(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/;
// correctly parse dates from local storage
export const dateReviver = (_key, value) => {
    if (typeof value === 'string' && detectDate.test(value)) {
        return new Date(value);
    }
    return value;
};
const dummyReviver = (_key, value) => value;
const checkIsBrowserEnv = () => {
    return typeof window !== 'undefined';
};
const validateStateKeys = (keys) => {
    return keys.map((key) => {
        let attr = key;
        if (typeof key === 'object') {
            attr = Object.keys(key)[0];
        }
        if (typeof attr !== 'string') {
            throw new TypeError(`localStorageSync Unknown Parameter Type: ` + `Expected type of string, got ${typeof attr}`);
        }
        return key;
    });
};
export const rehydrateApplicationState = (keys, storage, storageKeySerializer, restoreDates) => {
    return keys.reduce((acc, curr) => {
        let key = curr;
        let reviver = restoreDates ? dateReviver : dummyReviver;
        let deserialize;
        let decrypt;
        if (typeof key === 'object') {
            key = Object.keys(key)[0];
            // use the custom reviver function
            if (typeof curr[key] === 'function') {
                reviver = curr[key];
            }
            else {
                // use custom reviver function if available
                if (curr[key].reviver) {
                    reviver = curr[key].reviver;
                }
                // use custom serialize function if available
                if (curr[key].deserialize) {
                    deserialize = curr[key].deserialize;
                }
            }
            // Ensure that encrypt and decrypt functions are both present
            if (curr[key].encrypt && curr[key].decrypt) {
                if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {
                    decrypt = curr[key].decrypt;
                }
                else {
                    console.error(`Either encrypt or decrypt is not a function on '${curr[key]}' key object.`);
                }
            }
            else if (curr[key].encrypt || curr[key].decrypt) {
                // Let know that one of the encryption functions is not provided
                console.error(`Either encrypt or decrypt function is not present on '${curr[key]}' key object.`);
            }
        }
        if (storage !== undefined) {
            let stateSlice = storage.getItem(storageKeySerializer(key));
            if (stateSlice) {
                // Use provided decrypt function
                if (decrypt) {
                    stateSlice = decrypt(stateSlice);
                }
                const isObjectRegex = new RegExp('{|\\[');
                let raw = stateSlice;
                if (stateSlice === 'null' || stateSlice === 'true' || stateSlice === 'false' || isObjectRegex.test(stateSlice.charAt(0))) {
                    raw = JSON.parse(stateSlice, reviver);
                }
                return Object.assign({}, acc, {
                    [key]: deserialize ? deserialize(raw) : raw,
                });
            }
        }
        return acc;
    }, {});
};
// Recursively traverse all properties of the existing slice as defined by the `filter` argument,
// and output the new object with extraneous properties removed.
function createStateSlice(existingSlice, filter) {
    return filter.reduce((memo, attr) => {
        if (typeof attr === 'string' || typeof attr === 'number') {
            const value = existingSlice?.[attr];
            if (value !== undefined) {
                memo[attr] = value;
            }
        }
        else {
            for (const key in attr) {
                if (Object.prototype.hasOwnProperty.call(attr, key)) {
                    const element = attr[key];
                    memo[key] = createStateSlice(existingSlice[key], element);
                }
            }
        }
        return memo;
    }, {});
}
export const syncStateUpdate = (state, keys, storage, storageKeySerializer, removeOnUndefined, syncCondition) => {
    if (syncCondition) {
        try {
            if (syncCondition(state) !== true) {
                return;
            }
        }
        catch (e) {
            // Treat TypeError as do not sync
            if (e instanceof TypeError) {
                return;
            }
            throw e;
        }
    }
    keys.forEach((key) => {
        let stateSlice = state[key];
        let replacer;
        let space;
        let encrypt;
        if (typeof key === 'object') {
            let name = Object.keys(key)[0];
            stateSlice = state[name];
            if (typeof stateSlice !== 'undefined' && key[name]) {
                // use serialize function if specified.
                if (key[name].serialize) {
                    stateSlice = key[name].serialize(stateSlice);
                }
                else {
                    // if serialize function is not specified filter on fields if an array has been provided.
                    let filter;
                    if (key[name].reduce) {
                        filter = key[name];
                    }
                    else if (key[name].filter) {
                        filter = key[name].filter;
                    }
                    if (filter) {
                        stateSlice = createStateSlice(stateSlice, filter);
                    }
                    // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()
                    if (key[name].encrypt && key[name].decrypt) {
                        if (typeof key[name].encrypt === 'function') {
                            encrypt = key[name].encrypt;
                        }
                    }
                    else if (key[name].encrypt || key[name].decrypt) {
                        // If one of those is not present, then let know that one is missing
                        console.error(`Either encrypt or decrypt function is not present on '${key[name]}' key object.`);
                    }
                }
                /*
          Replacer and space arguments to pass to JSON.stringify.
          If these fields don't exist, undefined will be passed.
        */
                replacer = key[name].replacer;
                space = key[name].space;
            }
            key = name;
        }
        if (typeof stateSlice !== 'undefined' && storage !== undefined) {
            try {
                if (encrypt) {
                    // ensure that a string message is passed
                    stateSlice = encrypt(typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));
                }
                storage.setItem(storageKeySerializer(key), typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));
            }
            catch (e) {
                console.warn('Unable to save state to localStorage:', e);
            }
        }
        else if (typeof stateSlice === 'undefined' && removeOnUndefined && storage !== undefined) {
            try {
                storage.removeItem(storageKeySerializer(key));
            }
            catch (e) {
                console.warn(`Exception on removing/cleaning undefined '${key}' state`, e);
            }
        }
    });
};
// Default merge strategy is a full deep merge.
export const defaultMergeReducer = (state, rehydratedState, action) => {
    if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {
        const overwriteMerge = (destinationArray, sourceArray, options) => sourceArray;
        const options = {
            arrayMerge: overwriteMerge,
        };
        state = deepmerge(state, rehydratedState, options);
    }
    return state;
};
export const localStorageSync = (config) => (reducer) => {
    if ((config.storage === undefined && !config.checkStorageAvailability) ||
        (config.checkStorageAvailability && checkIsBrowserEnv())) {
        config.storage = localStorage || window.localStorage;
    }
    if (config.storageKeySerializer === undefined) {
        config.storageKeySerializer = (key) => key;
    }
    if (config.restoreDates === undefined) {
        config.restoreDates = true;
    }
    // Use default merge reducer.
    let mergeReducer = config.mergeReducer;
    if (mergeReducer === undefined || typeof mergeReducer !== 'function') {
        mergeReducer = defaultMergeReducer;
    }
    const stateKeys = validateStateKeys(config.keys);
    const rehydratedState = config.rehydrate
        ? rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates)
        : undefined;
    return function (state, action) {
        let nextState;
        // If state arrives undefined, we need to let it through the supplied reducer
        // in order to get a complete state as defined by user
        if (action.type === INIT_ACTION && !state) {
            nextState = reducer(state, action);
        }
        else {
            nextState = { ...state };
        }
        // Merge the store state with the rehydrated state using
        // either a user-defined reducer or the default.
        nextState = mergeReducer(nextState, rehydratedState, action);
        nextState = reducer(nextState, action);
        if (action.type !== INIT_ACTION) {
            syncStateUpdate(nextState, stateKeys, config.storage, config.storageKeySerializer, config.removeOnUndefined, config.syncCondition);
        }
        return nextState;
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9saWIvc3JjL2xpYi9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFNBQVMsTUFBTSxXQUFXLENBQUM7QUFFbEMsK0VBQStFO0FBQy9FLGtCQUFrQjtBQUNsQixNQUFNLFdBQVcsR0FBRyxrQkFBa0IsQ0FBQztBQUN2QyxNQUFNLGFBQWEsR0FBRyw2QkFBNkIsQ0FBQztBQUVwRCxNQUFNLFVBQVUsR0FBRyxpREFBaUQsQ0FBQztBQUVyRSwyQ0FBMkM7QUFDM0MsTUFBTSxDQUFDLE1BQU0sV0FBVyxHQUFHLENBQUMsSUFBWSxFQUFFLEtBQVUsRUFBRSxFQUFFO0lBQ3BELElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDckQsT0FBTyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUMxQjtJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2pCLENBQUMsQ0FBQztBQUVGLE1BQU0sWUFBWSxHQUFHLENBQUMsSUFBWSxFQUFFLEtBQVUsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDO0FBRXpELE1BQU0saUJBQWlCLEdBQUcsR0FBRyxFQUFFO0lBQzNCLE9BQU8sT0FBTyxNQUFNLEtBQUssV0FBVyxDQUFDO0FBQ3pDLENBQUMsQ0FBQztBQUVGLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxJQUFVLEVBQUUsRUFBRTtJQUNyQyxPQUFRLElBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtRQUMvQixJQUFJLElBQUksR0FBRyxHQUFHLENBQUM7UUFFZixJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtZQUN6QixJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM5QjtRQUVELElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO1lBQzFCLE1BQU0sSUFBSSxTQUFTLENBQ2YsMkNBQTJDLEdBQUcsZ0NBQWdDLE9BQU8sSUFBSSxFQUFFLENBQzlGLENBQUM7U0FDTDtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBRyxDQUNyQyxJQUFVLEVBQ1YsT0FBZ0IsRUFDaEIsb0JBQTZDLEVBQzdDLFlBQXFCLEVBQ3ZCLEVBQUU7SUFDQSxPQUFRLElBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUU7UUFDeEMsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDO1FBQ2YsSUFBSSxPQUFPLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQztRQUN4RCxJQUFJLFdBQWtDLENBQUM7UUFDdkMsSUFBSSxPQUFpQyxDQUFDO1FBRXRDLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO1lBQ3pCLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzFCLGtDQUFrQztZQUNsQyxJQUFJLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLFVBQVUsRUFBRTtnQkFDakMsT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUN2QjtpQkFBTTtnQkFDSCwyQ0FBMkM7Z0JBQzNDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRTtvQkFDbkIsT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7aUJBQy9CO2dCQUNELDZDQUE2QztnQkFDN0MsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFO29CQUN2QixXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsQ0FBQztpQkFDdkM7YUFDSjtZQUVELDZEQUE2RDtZQUM3RCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRTtnQkFDeEMsSUFBSSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEtBQUssVUFBVSxJQUFJLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sS0FBSyxVQUFVLEVBQUU7b0JBQ3BGLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDO2lCQUMvQjtxQkFBTTtvQkFDSCxPQUFPLENBQUMsS0FBSyxDQUFDLG1EQUFtRCxJQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxDQUFDO2lCQUM5RjthQUNKO2lCQUFNLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFO2dCQUMvQyxnRUFBZ0U7Z0JBQ2hFLE9BQU8sQ0FBQyxLQUFLLENBQUMseURBQXlELElBQUksQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUM7YUFDcEc7U0FDSjtRQUNELElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtZQUN2QixJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDNUQsSUFBSSxVQUFVLEVBQUU7Z0JBQ1osZ0NBQWdDO2dCQUNoQyxJQUFJLE9BQU8sRUFBRTtvQkFDVCxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2lCQUNwQztnQkFFRCxNQUFNLGFBQWEsR0FBRyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDMUMsSUFBSSxHQUFHLEdBQUcsVUFBVSxDQUFDO2dCQUVyQixJQUFJLFVBQVUsS0FBSyxNQUFNLElBQUksVUFBVSxLQUFLLE1BQU0sSUFBSSxVQUFVLEtBQUssT0FBTyxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO29CQUN0SCxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7aUJBQ3pDO2dCQUVELE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFO29CQUMxQixDQUFDLEdBQUcsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHO2lCQUM5QyxDQUFDLENBQUM7YUFDTjtTQUNKO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDWCxDQUFDLENBQUM7QUFFRixpR0FBaUc7QUFDakcsZ0VBQWdFO0FBQ2hFLFNBQVMsZ0JBQWdCLENBQUMsYUFBa0IsRUFBRSxNQUF3RDtJQUNsRyxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQ2hCLENBQUMsSUFBNEMsRUFBRSxJQUFrRCxFQUFFLEVBQUU7UUFDakcsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO1lBQ3RELE1BQU0sS0FBSyxHQUFHLGFBQWEsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3BDLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtnQkFDckIsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQzthQUN0QjtTQUNKO2FBQU07WUFDSCxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtnQkFDcEIsSUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFO29CQUNqRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQzFCLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7aUJBQzdEO2FBQ0o7U0FDSjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUMsRUFDRCxFQUFFLENBQ0wsQ0FBQztBQUNOLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxlQUFlLEdBQUcsQ0FDM0IsS0FBVSxFQUNWLElBQVUsRUFDVixPQUFnQixFQUNoQixvQkFBc0QsRUFDdEQsaUJBQTBCLEVBQzFCLGFBQW1DLEVBQ3JDLEVBQUU7SUFDQSxJQUFJLGFBQWEsRUFBRTtRQUNmLElBQUk7WUFDQSxJQUFJLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxJQUFJLEVBQUU7Z0JBQy9CLE9BQU87YUFDVjtTQUNKO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDUixpQ0FBaUM7WUFDakMsSUFBSSxDQUFDLFlBQVksU0FBUyxFQUFFO2dCQUN4QixPQUFPO2FBQ1Y7WUFDRCxNQUFNLENBQUMsQ0FBQztTQUNYO0tBQ0o7SUFFRCxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBNkUsRUFBUSxFQUFFO1FBQ2pHLElBQUksVUFBVSxHQUFHLEtBQUssQ0FBQyxHQUFhLENBQUMsQ0FBQztRQUN0QyxJQUFJLFFBQVEsQ0FBQztRQUNiLElBQUksS0FBc0IsQ0FBQztRQUMzQixJQUFJLE9BQU8sQ0FBQztRQUVaLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO1lBQ3pCLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0IsVUFBVSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUV6QixJQUFJLE9BQU8sVUFBVSxLQUFLLFdBQVcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ2hELHVDQUF1QztnQkFDdkMsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxFQUFFO29CQUNyQixVQUFVLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztpQkFDaEQ7cUJBQU07b0JBQ0gseUZBQXlGO29CQUN6RixJQUFJLE1BQTBCLENBQUM7b0JBQy9CLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRTt3QkFDbEIsTUFBTSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztxQkFDdEI7eUJBQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFO3dCQUN6QixNQUFNLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQztxQkFDN0I7b0JBQ0QsSUFBSSxNQUFNLEVBQUU7d0JBQ1IsVUFBVSxHQUFHLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxNQUFNLENBQUMsQ0FBQztxQkFDckQ7b0JBRUQsNkZBQTZGO29CQUM3RixJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRTt3QkFDeEMsSUFBSSxPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEtBQUssVUFBVSxFQUFFOzRCQUN6QyxPQUFPLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQzt5QkFDL0I7cUJBQ0o7eUJBQU0sSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUU7d0JBQy9DLG9FQUFvRTt3QkFDcEUsT0FBTyxDQUFDLEtBQUssQ0FDVCx5REFBeUQsR0FBRyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQ3BGLENBQUM7cUJBQ0w7aUJBQ0o7Z0JBRUQ7OztVQUdOO2dCQUNNLFFBQVEsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDO2dCQUM5QixLQUFLLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQzthQUMzQjtZQUVELEdBQUcsR0FBRyxJQUFJLENBQUM7U0FDZDtRQUVELElBQUksT0FBTyxVQUFVLEtBQUssV0FBVyxJQUFJLE9BQU8sS0FBSyxTQUFTLEVBQUU7WUFDNUQsSUFBSTtnQkFDQSxJQUFJLE9BQU8sRUFBRTtvQkFDVCx5Q0FBeUM7b0JBQ3pDLFVBQVUsR0FBRyxPQUFPLENBQ2hCLE9BQU8sVUFBVSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQzVGLENBQUM7aUJBQ0w7Z0JBQ0QsT0FBTyxDQUFDLE9BQU8sQ0FDWCxvQkFBb0IsQ0FBQyxHQUFhLENBQUMsRUFDbkMsT0FBTyxVQUFVLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FDNUYsQ0FBQzthQUNMO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1IsT0FBTyxDQUFDLElBQUksQ0FBQyx1Q0FBdUMsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUM1RDtTQUNKO2FBQU0sSUFBSSxPQUFPLFVBQVUsS0FBSyxXQUFXLElBQUksaUJBQWlCLElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtZQUN4RixJQUFJO2dCQUNBLE9BQU8sQ0FBQyxVQUFVLENBQUMsb0JBQW9CLENBQUMsR0FBYSxDQUFDLENBQUMsQ0FBQzthQUMzRDtZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNSLE9BQU8sQ0FBQyxJQUFJLENBQUMsNkNBQTZDLEdBQUcsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQzlFO1NBQ0o7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQztBQUVGLCtDQUErQztBQUMvQyxNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLEtBQVUsRUFBRSxlQUFvQixFQUFFLE1BQVcsRUFBRSxFQUFFO0lBQ2pGLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLFdBQVcsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLGFBQWEsQ0FBQyxJQUFJLGVBQWUsRUFBRTtRQUNuRixNQUFNLGNBQWMsR0FBRyxDQUFDLGdCQUFxQixFQUFFLFdBQWdCLEVBQUUsT0FBWSxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUM7UUFDOUYsTUFBTSxPQUFPLEdBQXNCO1lBQy9CLFVBQVUsRUFBRSxjQUFjO1NBQzdCLENBQUM7UUFFRixLQUFLLEdBQUcsU0FBUyxDQUFDLEtBQUssRUFBRSxlQUFlLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDdEQ7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNqQixDQUFDLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLE1BQTBCLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBWSxFQUFFLEVBQUU7SUFDN0UsSUFDSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEtBQUssU0FBUyxJQUFJLENBQUMsTUFBTSxDQUFDLHdCQUF3QixDQUFDO1FBQ2xFLENBQUMsTUFBTSxDQUFDLHdCQUF3QixJQUFJLGlCQUFpQixFQUFFLENBQUMsRUFDMUQ7UUFDRSxNQUFNLENBQUMsT0FBTyxHQUFHLFlBQVksSUFBSSxNQUFNLENBQUMsWUFBWSxDQUFDO0tBQ3hEO0lBRUQsSUFBSSxNQUFNLENBQUMsb0JBQW9CLEtBQUssU0FBUyxFQUFFO1FBQzNDLE1BQU0sQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDO0tBQzlDO0lBRUQsSUFBSSxNQUFNLENBQUMsWUFBWSxLQUFLLFNBQVMsRUFBRTtRQUNuQyxNQUFNLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztLQUM5QjtJQUVELDZCQUE2QjtJQUM3QixJQUFJLFlBQVksR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDO0lBRXZDLElBQUksWUFBWSxLQUFLLFNBQVMsSUFBSSxPQUFPLFlBQVksS0FBSyxVQUFVLEVBQUU7UUFDbEUsWUFBWSxHQUFHLG1CQUFtQixDQUFDO0tBQ3RDO0lBRUQsTUFBTSxTQUFTLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pELE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxTQUFTO1FBQ3BDLENBQUMsQ0FBQyx5QkFBeUIsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsb0JBQW9CLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQztRQUN4RyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBRWhCLE9BQU8sVUFBVSxLQUFVLEVBQUUsTUFBVztRQUNwQyxJQUFJLFNBQWMsQ0FBQztRQUVuQiw2RUFBNkU7UUFDN0Usc0RBQXNEO1FBQ3RELElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxXQUFXLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDdkMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDdEM7YUFBTTtZQUNILFNBQVMsR0FBRyxFQUFFLEdBQUcsS0FBSyxFQUFFLENBQUM7U0FDNUI7UUFFRCx3REFBd0Q7UUFDeEQsZ0RBQWdEO1FBQ2hELFNBQVMsR0FBRyxZQUFZLENBQUMsU0FBUyxFQUFFLGVBQWUsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUU3RCxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUV2QyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssV0FBVyxFQUFFO1lBQzdCLGVBQWUsQ0FDWCxTQUFTLEVBQ1QsU0FBUyxFQUNULE1BQU0sQ0FBQyxPQUFPLEVBQ2QsTUFBTSxDQUFDLG9CQUF3RCxFQUMvRCxNQUFNLENBQUMsaUJBQWlCLEVBQ3hCLE1BQU0sQ0FBQyxhQUFhLENBQ3ZCLENBQUM7U0FDTDtRQUVELE9BQU8sU0FBUyxDQUFDO0lBQ3JCLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcblxuLy8gQ2Fubm90IGltcG9ydCBmcm9tIHRoZSBAbmdyeC9zdG9yZSBwYWNrYWdlIGR1ZSB0byBhIG1vZHVsZSByZXNvbHV0aW9uIGlzc3VlLlxuLy8gU2VlIElzc3VlICMyMDYuXG5jb25zdCBJTklUX0FDVElPTiA9ICdAbmdyeC9zdG9yZS9pbml0JztcbmNvbnN0IFVQREFURV9BQ1RJT04gPSAnQG5ncngvc3RvcmUvdXBkYXRlLXJlZHVjZXJzJztcblxuY29uc3QgZGV0ZWN0RGF0ZSA9IC8oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KVQoXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KS87XG5cbi8vIGNvcnJlY3RseSBwYXJzZSBkYXRlcyBmcm9tIGxvY2FsIHN0b3JhZ2VcbmV4cG9ydCBjb25zdCBkYXRlUmV2aXZlciA9IChfa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBkZXRlY3REYXRlLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbmNvbnN0IGR1bW15UmV2aXZlciA9IChfa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IHZhbHVlO1xuXG5jb25zdCBjaGVja0lzQnJvd3NlckVudiA9ICgpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuXG5jb25zdCB2YWxpZGF0ZVN0YXRlS2V5cyA9IChrZXlzOiBLZXlzKSA9PiB7XG4gICAgcmV0dXJuIChrZXlzIGFzIGFueVtdKS5tYXAoKGtleSkgPT4ge1xuICAgICAgICBsZXQgYXR0ciA9IGtleTtcblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGF0dHIgPSBPYmplY3Qua2V5cyhrZXkpWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgbG9jYWxTdG9yYWdlU3luYyBVbmtub3duIFBhcmFtZXRlciBUeXBlOiBgICsgYEV4cGVjdGVkIHR5cGUgb2Ygc3RyaW5nLCBnb3QgJHt0eXBlb2YgYXR0cn1gXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVoeWRyYXRlQXBwbGljYXRpb25TdGF0ZSA9IChcbiAgICBrZXlzOiBLZXlzLFxuICAgIHN0b3JhZ2U6IFN0b3JhZ2UsXG4gICAgc3RvcmFnZUtleVNlcmlhbGl6ZXI6IChrZXk6IHN0cmluZykgPT4gc3RyaW5nLFxuICAgIHJlc3RvcmVEYXRlczogYm9vbGVhblxuKSA9PiB7XG4gICAgcmV0dXJuIChrZXlzIGFzIGFueVtdKS5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgICBsZXQga2V5ID0gY3VycjtcbiAgICAgICAgbGV0IHJldml2ZXIgPSByZXN0b3JlRGF0ZXMgPyBkYXRlUmV2aXZlciA6IGR1bW15UmV2aXZlcjtcbiAgICAgICAgbGV0IGRlc2VyaWFsaXplOiAoYXJnMDogc3RyaW5nKSA9PiBhbnk7XG4gICAgICAgIGxldCBkZWNyeXB0OiAoYXJnMDogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBrZXkgPSBPYmplY3Qua2V5cyhrZXkpWzBdO1xuICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXN0b20gcmV2aXZlciBmdW5jdGlvblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXZpdmVyID0gY3VycltrZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgY3VzdG9tIHJldml2ZXIgZnVuY3Rpb24gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJba2V5XS5yZXZpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldml2ZXIgPSBjdXJyW2tleV0ucmV2aXZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdXNlIGN1c3RvbSBzZXJpYWxpemUgZnVuY3Rpb24gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJba2V5XS5kZXNlcmlhbGl6ZSkge1xuICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZSA9IGN1cnJba2V5XS5kZXNlcmlhbGl6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGVuY3J5cHQgYW5kIGRlY3J5cHQgZnVuY3Rpb25zIGFyZSBib3RoIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChjdXJyW2tleV0uZW5jcnlwdCAmJiBjdXJyW2tleV0uZGVjcnlwdCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycltrZXldLmVuY3J5cHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGN1cnJba2V5XS5kZWNyeXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY3J5cHQgPSBjdXJyW2tleV0uZGVjcnlwdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFaXRoZXIgZW5jcnlwdCBvciBkZWNyeXB0IGlzIG5vdCBhIGZ1bmN0aW9uIG9uICcke2N1cnJba2V5XX0nIGtleSBvYmplY3QuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyW2tleV0uZW5jcnlwdCB8fCBjdXJyW2tleV0uZGVjcnlwdCkge1xuICAgICAgICAgICAgICAgIC8vIExldCBrbm93IHRoYXQgb25lIG9mIHRoZSBlbmNyeXB0aW9uIGZ1bmN0aW9ucyBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFaXRoZXIgZW5jcnlwdCBvciBkZWNyeXB0IGZ1bmN0aW9uIGlzIG5vdCBwcmVzZW50IG9uICcke2N1cnJba2V5XX0nIGtleSBvYmplY3QuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3JhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHN0YXRlU2xpY2UgPSBzdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleVNlcmlhbGl6ZXIoa2V5KSk7XG4gICAgICAgICAgICBpZiAoc3RhdGVTbGljZSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBwcm92aWRlZCBkZWNyeXB0IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGRlY3J5cHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTbGljZSA9IGRlY3J5cHQoc3RhdGVTbGljZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNPYmplY3RSZWdleCA9IG5ldyBSZWdFeHAoJ3t8XFxcXFsnKTtcbiAgICAgICAgICAgICAgICBsZXQgcmF3ID0gc3RhdGVTbGljZTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZVNsaWNlID09PSAnbnVsbCcgfHwgc3RhdGVTbGljZSA9PT0gJ3RydWUnIHx8IHN0YXRlU2xpY2UgPT09ICdmYWxzZScgfHwgaXNPYmplY3RSZWdleC50ZXN0KHN0YXRlU2xpY2UuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgICByYXcgPSBKU09OLnBhcnNlKHN0YXRlU2xpY2UsIHJldml2ZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBhY2MsIHtcbiAgICAgICAgICAgICAgICAgICAgW2tleV06IGRlc2VyaWFsaXplID8gZGVzZXJpYWxpemUocmF3KSA6IHJhdyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn07XG5cbi8vIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBleGlzdGluZyBzbGljZSBhcyBkZWZpbmVkIGJ5IHRoZSBgZmlsdGVyYCBhcmd1bWVudCxcbi8vIGFuZCBvdXRwdXQgdGhlIG5ldyBvYmplY3Qgd2l0aCBleHRyYW5lb3VzIHByb3BlcnRpZXMgcmVtb3ZlZC5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlU2xpY2UoZXhpc3RpbmdTbGljZTogYW55LCBmaWx0ZXI6IChzdHJpbmcgfCBudW1iZXIgfCBLZXlDb25maWd1cmF0aW9uIHwgT3B0aW9ucylbXSkge1xuICAgIHJldHVybiBmaWx0ZXIucmVkdWNlKFxuICAgICAgICAobWVtbzogeyBbeDogc3RyaW5nXTogYW55OyBbeDogbnVtYmVyXTogYW55IH0sIGF0dHI6IHN0cmluZyB8IG51bWJlciB8IEtleUNvbmZpZ3VyYXRpb24gfCBPcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGF0dHIgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhdHRyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXhpc3RpbmdTbGljZT8uW2F0dHJdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9bYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gYXR0cltrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVtb1trZXldID0gY3JlYXRlU3RhdGVTbGljZShleGlzdGluZ1NsaWNlW2tleV0sIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sXG4gICAgICAgIHt9XG4gICAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IHN5bmNTdGF0ZVVwZGF0ZSA9IChcbiAgICBzdGF0ZTogYW55LFxuICAgIGtleXM6IEtleXMsXG4gICAgc3RvcmFnZTogU3RvcmFnZSxcbiAgICBzdG9yYWdlS2V5U2VyaWFsaXplcjogKGtleTogc3RyaW5nIHwgbnVtYmVyKSA9PiBzdHJpbmcsXG4gICAgcmVtb3ZlT25VbmRlZmluZWQ6IGJvb2xlYW4sXG4gICAgc3luY0NvbmRpdGlvbj86IChzdGF0ZTogYW55KSA9PiBhbnlcbikgPT4ge1xuICAgIGlmIChzeW5jQ29uZGl0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc3luY0NvbmRpdGlvbihzdGF0ZSkgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRyZWF0IFR5cGVFcnJvciBhcyBkbyBub3Qgc3luY1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAga2V5cy5mb3JFYWNoKChrZXk6IHN0cmluZyB8IEtleUNvbmZpZ3VyYXRpb24gfCBPcHRpb25zIHwgKChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gYW55KSk6IHZvaWQgPT4ge1xuICAgICAgICBsZXQgc3RhdGVTbGljZSA9IHN0YXRlW2tleSBhcyBzdHJpbmddO1xuICAgICAgICBsZXQgcmVwbGFjZXI7XG4gICAgICAgIGxldCBzcGFjZTogc3RyaW5nIHwgbnVtYmVyO1xuICAgICAgICBsZXQgZW5jcnlwdDtcblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gT2JqZWN0LmtleXMoa2V5KVswXTtcbiAgICAgICAgICAgIHN0YXRlU2xpY2UgPSBzdGF0ZVtuYW1lXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZVNsaWNlICE9PSAndW5kZWZpbmVkJyAmJiBrZXlbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAvLyB1c2Ugc2VyaWFsaXplIGZ1bmN0aW9uIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoa2V5W25hbWVdLnNlcmlhbGl6ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVNsaWNlID0ga2V5W25hbWVdLnNlcmlhbGl6ZShzdGF0ZVNsaWNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBzZXJpYWxpemUgZnVuY3Rpb24gaXMgbm90IHNwZWNpZmllZCBmaWx0ZXIgb24gZmllbGRzIGlmIGFuIGFycmF5IGhhcyBiZWVuIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsdGVyOiBLZXlDb25maWd1cmF0aW9uW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlbbmFtZV0ucmVkdWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBrZXlbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5W25hbWVdLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0ga2V5W25hbWVdLmZpbHRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVNsaWNlID0gY3JlYXRlU3RhdGVTbGljZShzdGF0ZVNsaWNlLCBmaWx0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZW5jcnlwdCBhbmQgZGVjcnlwdCBhcmUgcHJlc2VudCwgYWxzbyBjaGVja2VkIGF0IHRoaXMjcmVoeWRyYXRlQXBwbGljYXRpb25TdGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlbbmFtZV0uZW5jcnlwdCAmJiBrZXlbbmFtZV0uZGVjcnlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXlbbmFtZV0uZW5jcnlwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY3J5cHQgPSBrZXlbbmFtZV0uZW5jcnlwdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlbbmFtZV0uZW5jcnlwdCB8fCBrZXlbbmFtZV0uZGVjcnlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgb25lIG9mIHRob3NlIGlzIG5vdCBwcmVzZW50LCB0aGVuIGxldCBrbm93IHRoYXQgb25lIGlzIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYEVpdGhlciBlbmNyeXB0IG9yIGRlY3J5cHQgZnVuY3Rpb24gaXMgbm90IHByZXNlbnQgb24gJyR7a2V5W25hbWVdfScga2V5IG9iamVjdC5gXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICBSZXBsYWNlciBhbmQgc3BhY2UgYXJndW1lbnRzIHRvIHBhc3MgdG8gSlNPTi5zdHJpbmdpZnkuXG4gICAgICAgICAgSWYgdGhlc2UgZmllbGRzIGRvbid0IGV4aXN0LCB1bmRlZmluZWQgd2lsbCBiZSBwYXNzZWQuXG4gICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVwbGFjZXIgPSBrZXlbbmFtZV0ucmVwbGFjZXI7XG4gICAgICAgICAgICAgICAgc3BhY2UgPSBrZXlbbmFtZV0uc3BhY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGtleSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlU2xpY2UgIT09ICd1bmRlZmluZWQnICYmIHN0b3JhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jcnlwdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCBhIHN0cmluZyBtZXNzYWdlIGlzIHBhc3NlZFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVNsaWNlID0gZW5jcnlwdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzdGF0ZVNsaWNlID09PSAnc3RyaW5nJyA/IHN0YXRlU2xpY2UgOiBKU09OLnN0cmluZ2lmeShzdGF0ZVNsaWNlLCByZXBsYWNlciwgc3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZUtleVNlcmlhbGl6ZXIoa2V5IGFzIHN0cmluZyksXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzdGF0ZVNsaWNlID09PSAnc3RyaW5nJyA/IHN0YXRlU2xpY2UgOiBKU09OLnN0cmluZ2lmeShzdGF0ZVNsaWNlLCByZXBsYWNlciwgc3BhY2UpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBzYXZlIHN0YXRlIHRvIGxvY2FsU3RvcmFnZTonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhdGVTbGljZSA9PT0gJ3VuZGVmaW5lZCcgJiYgcmVtb3ZlT25VbmRlZmluZWQgJiYgc3RvcmFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5U2VyaWFsaXplcihrZXkgYXMgc3RyaW5nKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBFeGNlcHRpb24gb24gcmVtb3ZpbmcvY2xlYW5pbmcgdW5kZWZpbmVkICcke2tleX0nIHN0YXRlYCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8vIERlZmF1bHQgbWVyZ2Ugc3RyYXRlZ3kgaXMgYSBmdWxsIGRlZXAgbWVyZ2UuXG5leHBvcnQgY29uc3QgZGVmYXVsdE1lcmdlUmVkdWNlciA9IChzdGF0ZTogYW55LCByZWh5ZHJhdGVkU3RhdGU6IGFueSwgYWN0aW9uOiBhbnkpID0+IHtcbiAgICBpZiAoKGFjdGlvbi50eXBlID09PSBJTklUX0FDVElPTiB8fCBhY3Rpb24udHlwZSA9PT0gVVBEQVRFX0FDVElPTikgJiYgcmVoeWRyYXRlZFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG92ZXJ3cml0ZU1lcmdlID0gKGRlc3RpbmF0aW9uQXJyYXk6IGFueSwgc291cmNlQXJyYXk6IGFueSwgb3B0aW9uczogYW55KSA9PiBzb3VyY2VBcnJheTtcbiAgICAgICAgY29uc3Qgb3B0aW9uczogZGVlcG1lcmdlLk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhcnJheU1lcmdlOiBvdmVyd3JpdGVNZXJnZSxcbiAgICAgICAgfTtcblxuICAgICAgICBzdGF0ZSA9IGRlZXBtZXJnZShzdGF0ZSwgcmVoeWRyYXRlZFN0YXRlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGU7XG59O1xuXG5leHBvcnQgY29uc3QgbG9jYWxTdG9yYWdlU3luYyA9IChjb25maWc6IExvY2FsU3RvcmFnZUNvbmZpZykgPT4gKHJlZHVjZXI6IGFueSkgPT4ge1xuICAgIGlmIChcbiAgICAgICAgKGNvbmZpZy5zdG9yYWdlID09PSB1bmRlZmluZWQgJiYgIWNvbmZpZy5jaGVja1N0b3JhZ2VBdmFpbGFiaWxpdHkpIHx8XG4gICAgICAgIChjb25maWcuY2hlY2tTdG9yYWdlQXZhaWxhYmlsaXR5ICYmIGNoZWNrSXNCcm93c2VyRW52KCkpXG4gICAgKSB7XG4gICAgICAgIGNvbmZpZy5zdG9yYWdlID0gbG9jYWxTdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5zdG9yYWdlS2V5U2VyaWFsaXplciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbmZpZy5zdG9yYWdlS2V5U2VyaWFsaXplciA9IChrZXkpID0+IGtleTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLnJlc3RvcmVEYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbmZpZy5yZXN0b3JlRGF0ZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFVzZSBkZWZhdWx0IG1lcmdlIHJlZHVjZXIuXG4gICAgbGV0IG1lcmdlUmVkdWNlciA9IGNvbmZpZy5tZXJnZVJlZHVjZXI7XG5cbiAgICBpZiAobWVyZ2VSZWR1Y2VyID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1lcmdlUmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtZXJnZVJlZHVjZXIgPSBkZWZhdWx0TWVyZ2VSZWR1Y2VyO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlS2V5cyA9IHZhbGlkYXRlU3RhdGVLZXlzKGNvbmZpZy5rZXlzKTtcbiAgICBjb25zdCByZWh5ZHJhdGVkU3RhdGUgPSBjb25maWcucmVoeWRyYXRlXG4gICAgICAgID8gcmVoeWRyYXRlQXBwbGljYXRpb25TdGF0ZShzdGF0ZUtleXMsIGNvbmZpZy5zdG9yYWdlLCBjb25maWcuc3RvcmFnZUtleVNlcmlhbGl6ZXIsIGNvbmZpZy5yZXN0b3JlRGF0ZXMpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZTogYW55LCBhY3Rpb246IGFueSkge1xuICAgICAgICBsZXQgbmV4dFN0YXRlOiBhbnk7XG5cbiAgICAgICAgLy8gSWYgc3RhdGUgYXJyaXZlcyB1bmRlZmluZWQsIHdlIG5lZWQgdG8gbGV0IGl0IHRocm91Z2ggdGhlIHN1cHBsaWVkIHJlZHVjZXJcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gZ2V0IGEgY29tcGxldGUgc3RhdGUgYXMgZGVmaW5lZCBieSB1c2VyXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gSU5JVF9BQ1RJT04gJiYgIXN0YXRlKSB7XG4gICAgICAgICAgICBuZXh0U3RhdGUgPSByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dFN0YXRlID0geyAuLi5zdGF0ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWVyZ2UgdGhlIHN0b3JlIHN0YXRlIHdpdGggdGhlIHJlaHlkcmF0ZWQgc3RhdGUgdXNpbmdcbiAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1kZWZpbmVkIHJlZHVjZXIgb3IgdGhlIGRlZmF1bHQuXG4gICAgICAgIG5leHRTdGF0ZSA9IG1lcmdlUmVkdWNlcihuZXh0U3RhdGUsIHJlaHlkcmF0ZWRTdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgICBuZXh0U3RhdGUgPSByZWR1Y2VyKG5leHRTdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgIT09IElOSVRfQUNUSU9OKSB7XG4gICAgICAgICAgICBzeW5jU3RhdGVVcGRhdGUoXG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlLFxuICAgICAgICAgICAgICAgIHN0YXRlS2V5cyxcbiAgICAgICAgICAgICAgICBjb25maWcuc3RvcmFnZSxcbiAgICAgICAgICAgICAgICBjb25maWcuc3RvcmFnZUtleVNlcmlhbGl6ZXIgYXMgKGtleTogc3RyaW5nIHwgbnVtYmVyKSA9PiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgY29uZmlnLnJlbW92ZU9uVW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbmZpZy5zeW5jQ29uZGl0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICB9O1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBMb2NhbFN0b3JhZ2VDb25maWcge1xuICAgIGtleXM6IEtleXM7XG4gICAgcmVoeWRyYXRlPzogYm9vbGVhbjtcbiAgICBzdG9yYWdlPzogU3RvcmFnZTtcbiAgICByZW1vdmVPblVuZGVmaW5lZD86IGJvb2xlYW47XG4gICAgcmVzdG9yZURhdGVzPzogYm9vbGVhbjtcbiAgICBzdG9yYWdlS2V5U2VyaWFsaXplcj86IChrZXk6IHN0cmluZykgPT4gc3RyaW5nO1xuICAgIHN5bmNDb25kaXRpb24/OiAoc3RhdGU6IGFueSkgPT4gYW55O1xuICAgIGNoZWNrU3RvcmFnZUF2YWlsYWJpbGl0eT86IGJvb2xlYW47XG4gICAgbWVyZ2VSZWR1Y2VyPzogKHN0YXRlOiBhbnksIHJlaHlkcmF0ZWRTdGF0ZTogYW55LCBhY3Rpb246IGFueSkgPT4gYW55O1xufVxuXG5pbnRlcmZhY2UgS2V5Q29uZmlndXJhdGlvbiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nW10gfCBudW1iZXJbXSB8IEtleUNvbmZpZ3VyYXRpb25bXSB8IE9wdGlvbnMgfCAoKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBhbnkpO1xufVxuXG5pbnRlcmZhY2UgT3B0aW9ucyB7XG4gICAgc2VyaWFsaXplPzogKHN0YXRlOiBhbnkpID0+IGFueTtcbiAgICBkZXNlcmlhbGl6ZT86IChzdGF0ZTogYW55KSA9PiBhbnk7XG4gICAgcmV2aXZlcj86IChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gYW55O1xuICAgIHJlcGxhY2VyPzogKChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gYW55KSB8IHN0cmluZ1tdO1xuICAgIGVuY3J5cHQ/OiAobWVzc2FnZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgZGVjcnlwdD86IChtZXNzYWdlOiBzdHJpbmcpID0+IHN0cmluZztcbiAgICBmaWx0ZXI/OiBzdHJpbmdbXTtcbiAgICBzcGFjZT86IHN0cmluZyB8IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgS2V5cyA9IChLZXlDb25maWd1cmF0aW9uIHwgT3B0aW9uc3wgc3RyaW5nKVtdO1xuIl19